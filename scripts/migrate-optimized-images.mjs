import fs from 'node:fs';
import path from 'node:path';
import childProcess from 'node:child_process';

const projectRoot = process.cwd();
const optimizedTsPath = path.join(projectRoot, 'src', 'generated', 'optimized-images.ts');
const optimizedRoot = path.join(projectRoot, 'public', 'optimized');
const outPublicRoot = path.join(projectRoot, 'public', 'images');
const outTsPath = path.join(projectRoot, 'src', 'generated', 'image-masters.ts');

function die(msg) {
  console.error(msg);
  process.exit(1);
}

if (!fs.existsSync(optimizedTsPath)) die(`Missing ${optimizedTsPath}`);
if (!fs.existsSync(optimizedRoot)) die(`Missing ${optimizedRoot}`);

const fileText = fs.readFileSync(optimizedTsPath, 'utf8');

// Extract only the keys we actually use for the UI layer.
// Keeping this small is the point of the migration.
const keyRegex = /\"((?:site|logo)\/[^\"]+)\"\s*:\s*\{/g;
const keys = new Set();
for (const m of fileText.matchAll(keyRegex)) keys.add(m[1]);

const sortedKeys = [...keys].sort();
if (sortedKeys.length === 0) die('No site/logo keys found in optimized-images.ts');

function listFiles(dir) {
  try {
    return fs.readdirSync(dir).map((f) => path.join(dir, f));
  } catch {
    return [];
  }
}

function pickMasterFile({ dir, baseName }) {
  const files = listFiles(dir).filter((f) => fs.statSync(f).isFile());

  // Prefer webp, then png, then jpg/jpeg.
  const candidatesByExt = [
    { exts: ['.webp'], label: 'webp' },
    { exts: ['.png'], label: 'png' },
    { exts: ['.jpg', '.jpeg'], label: 'jpg' },
  ];

  for (const group of candidatesByExt) {
    const groupFiles = files
      .filter((f) => group.exts.includes(path.extname(f).toLowerCase()))
      .filter((f) => path.basename(f).startsWith(baseName + '-'))
      .map((f) => {
        const bn = path.basename(f);
        const m = bn.match(/-(\d+)\.[^.]+$/);
        const w = m ? Number(m[1]) : 0;
        return { f, w };
      })
      .sort((a, b) => b.w - a.w);

    if (groupFiles.length > 0) return groupFiles[0].f;
  }

  return null;
}

function getImageSize(filePath) {
  // Use macOS `sips` to read dimensions without adding dependencies.
  const out = childProcess.execSync(`sips -g pixelWidth -g pixelHeight ${JSON.stringify(filePath)}`, {
    encoding: 'utf8',
  });
  const w = out.match(/pixelWidth:\s*(\d+)/)?.[1];
  const h = out.match(/pixelHeight:\s*(\d+)/)?.[1];
  if (!w || !h) throw new Error(`Could not read size for ${filePath}`);
  return { width: Number(w), height: Number(h) };
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

const masters = {};
const problems = [];

for (const key of sortedKeys) {
  const [kind, slug] = key.split('/', 2);
  const isSite = kind === 'site';
  const srcDir = isSite
    ? path.join(optimizedRoot, 'site', slug)
    : path.join(optimizedRoot, 'logos', slug);

  const master = pickMasterFile({ dir: srcDir, baseName: slug });
  if (!master) {
    problems.push({ key, reason: `No master found in ${srcDir}` });
    continue;
  }

  const ext = path.extname(master).toLowerCase();
  const outDir = path.join(outPublicRoot, isSite ? 'site' : 'logo');
  ensureDir(outDir);

  const outName = `${slug}${ext}`;
  const outAbs = path.join(outDir, outName);
  const outWeb = `/images/${isSite ? 'site' : 'logo'}/${outName}`;

  fs.copyFileSync(master, outAbs);

  let size;
  try {
    size = getImageSize(outAbs);
  } catch (e) {
    problems.push({ key, reason: String(e) });
    continue;
  }

  masters[key] = {
    src: outWeb,
    width: size.width,
    height: size.height,
  };
}

if (problems.length) {
  console.error('Some keys could not be migrated:');
  for (const p of problems) console.error(`- ${p.key}: ${p.reason}`);
}

const header = `// AUTO-GENERATED by scripts/migrate-optimized-images.mjs\n// Source: public/optimized (largest variant per key).\n// Keep this file small; it is intentionally a "master" map only.\n\nexport type ImageMaster = { src: string; width: number; height: number };\n\nexport const IMAGE_MASTERS: Record<string, ImageMaster> = `;

const ts = header + JSON.stringify(masters, null, 2) + ';\n';
fs.writeFileSync(outTsPath, ts, 'utf8');

console.log(`Migrated ${Object.keys(masters).length}/${sortedKeys.length} keys.`);
console.log(`Wrote ${outTsPath}`);
